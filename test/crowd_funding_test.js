let CrowdFundingWithDeadline = artifacts.require //importing SC
('./TestCrowdFundingWithDeadline')

contract('CrowdFundingWithDeadline', function (accounts) {
    //fields
    let contract; //reference to SC
    let contract1;
    let contractCreator = accounts[0]; //address that will deploy SC
    let beneficiary = accounts[1];// address of beneficiary 

    const ONE_ETH = '1000000000000000000'; 
    const ERROR_MSG = 'Returned error: VM Exception while processing transaction: revert';
    const ONGOING_STATE = '0';
    const FAILED_STATE = '1';
    const SUCCEEDED_STATE = '2';
    const PAID_OUT_STATE = '3';

    //deploying an instance of SC in test environment
    beforeEach(async function(){ //beforeEach -> before every 'it' it is initialized and it erases all the values
        contract = await CrowdFundingWithDeadline.new( //using the object of our SC and calling the 'new' method
            //we need to provide 4 parameters
            'funding', //contract name
            1, //target amount
            10, //duration in mins
            beneficiary, //ben. address
            //we have to provide two more parameters 
            {
                from: contractCreator, //address of an account that will deploy this Sc 
                gas: 2000000 //max amount of gas that we are willing to pay to deploy SC
            }
        

        );
        //console.log(accounts);
            
    });
    
    //first test
    it('contract is initialized', async function(){ //checking if all the fields in this SC were initialized correctly
        let address = await contract.checkAddress.call();
        //console.log(address)
        
        let campaignName = await contract.name.call() //checking if the campaignName is the one we passed in the constructor using 'call' mechanism and providing name of our field 'name'
        expect(campaignName).to.equal('funding');

        let targetAmount = await contract.targetAmount.call()
        //console.log(targetAmount)
        expect(targetAmount.toString()).to.equal(ONE_ETH);//converting targetAmount to JavaScript number and then verify value using the constance that we provided

        let fundingDeadLine = await contract.fundingDeadLine.call()
        expect(fundingDeadLine.toNumber()).to.equal(600)

        let actualBeneficiary = await contract.beneficiary.call()
        //console.log(beneficiary)
        //console.log(actualBeneficiary)
        expect(actualBeneficiary).to.equal(beneficiary);

        let state = await contract.state.call()
        //console.log(state)
        //Truffle contract returns from enum field -> an object, which has the valueOf method, which is a string that contains the position of the enum vaule in the enum definition
        expect(state.valueOf().toString()).to.equal(ONGOING_STATE);

    });

    it('funds are contributed', async function(){
       await contract.contribute({ //execute the contribute method and send 1 ethet with this method, need to specif an account from which to send this transaction 
        value: ONE_ETH,
        from: contractCreator
        });
        //cheching if SC has recorded that the contract creator has contributed 1 Ether
        let contributed = await contract.amounts //using amounts method because amounts is a public field
            .call(contractCreator);//for types like Boolean or uint solidity generates a getter that returns the value of this variable, but for mpping solidity generates a method that has one parameter which is the key in this map (12 line in contract)
            //and the method that was generated by solidity will return a value for this key
        expect(contributed.toString()).to.equal(ONE_ETH);
        //we called the generatedAmounts method and passed the key in this amounts map and then we check that the contract creator has contributed 1 Ether
        let totalCollected = await contract.totalCollected.call()
        expect(totalCollected.toString()).to.equal(ONE_ETH);

    })

    it('cannot contribute after deadline', async function(){
        try {
            await contract.setCurrentTime(601); //seting time one second after our deadline
            await contract.sendTransaction({ //and then try to contribute to our camaipgn
                value: ONE_ETH,
                from: contractCreator
            });
            expect.fail(); //adding fail methond call to ensure that an exception was thrown during the test execution
        } catch(error){
            expect(error.message).to.equal(ERROR_MSG);
        }
    })

    it('Crowdfunding Succeded', async function(){
        await contract.contribute({value: ONE_ETH, from: contractCreator});
        await contract.setCurrentTime(601);
        await contract.finishCrowdFunding();
        let state = await contract.state.call();
        expect(state.valueOf().toString()).to.equal(SUCCEEDED_STATE);
    })

    it('Crowdfunding Failed', async function(){
        await contract.setCurrentTime(601);
        await contract.finishCrowdFunding();
        let state = await contract.state.call();
        expect(state.valueOf().toString()).to.equal(FAILED_STATE);
    })

    it('collected money paid out', async function(){
        await contract.contribute({value: ONE_ETH, from: contractCreator});
        await contract.setCurrentTime(601);
        await contract.finishCrowdFunding();

        let initAmount = await web3.eth.getBalance(beneficiary);
        await contract.collect({from:contractCreator});

        let newBalance = await web3.eth.getBalance(beneficiary)
        expect((newBalance - initAmount).toString()).to.equal(ONE_ETH);

        let state = await contract.state.call();
        expect(state.valueOf().toString()).to.equal(PAID_OUT_STATE);
    })

    it('withdraw funds from the contract', async function(){
        await contract.contribute({value: ONE_ETH - 100, from: contractCreator});
        await contract.setCurrentTime(601);
        await contract.finishCrowdFunding();

        await contract.withdraw({from: contractCreator});
        let amount = await contract.amounts.call(contractCreator);
        expect(amount.toNumber()).to.equal(0);
        
    })
/*
    it('event is emittedxx', async function(){
        let watcher = contract.CampaignFinished(); //create a watcher that will receive events from a SC, API is different from web3js API. To create a watcher for a specific event type I need to use 'contract' instance, then the name of the event I want to listen to. 
        console.log('dupa');
        console.log(watcher);
        await contract.setCurrentTime(601);
        await contract.finishCrowdFunding(); //need to interact with SC and finish crowdfunding
        //the goal to the FinishCrowdFunding will emit the CampaignFinished event. Now when this event is emitted there are two ways to get event from watcher
        //1. subscribe for events from the watcher
        //2. get events that this watcher has received -> this we will use
        let events = await watcher.get(); //using get method
        let event = events[0]; //events is an array of events, so we get the first event in array
        //we need to validate that this event was created with the right arguments
        expect(event.args.totalCollected.toNumber()).to.equal(0);//check if the total collected ammount is equal to 0, because there was no contribution
        expect(event.args.succeeded).to.equal(false);//verify that this campaing has failed - the succeeded flag is equal to false
    })
    
 //wersja na getPastEvents
    it('event is emittedxx', async function(){
        let watcher = contract.getPastEvents('CampaignFinished', { fromBlock: 0, toBlock: 'latest' }, function(error, events){ console.log(events); }).then(console.log); //create a watcher that will receive events from a SC, API is different from web3js API. To create a watcher for a specific event type I need to use 'contract' instance, then the name of the event I want to listen to. 
        console.log('dupa');
        console.log(await web3.eth.getBlock("latest"))
        console.log(await watcher);

        await contract.setCurrentTime(601);
        await contract.finishCrowdFunding(); //need to interact with SC and finish crowdfunding
        //the goal to the FinishCrowdFunding will emit the CampaignFinished event. Now when this event is emitted there are two ways to get event from watcher
        //1. subscribe for events from the watcher
        //2. get events that this watcher has received -> this we will use
        console.log(watcher);
        let events = await watcher.get(); //using get method
        let event = events[0]; //events is an array of events, so we get the first event in array
        //we need to validate that this event was created with the right arguments
        expect(event.args.totalCollected.toNumber()).to.equal(0);//check if the total collected ammount is equal to 0, because there was no contribution
        expect(event.args.succeeded).to.equal(false);//verify that this campaing has failed - the succeeded flag is equal to false
    })

*/
    it('event is emitted', async function(){
        await contract.setCurrentTime(601);
        let res = await contract.finishCrowdFunding();
        let eventName = res.logs[0].event;
        let eventRes = res.logs[0].args;
        expect(Number.parseInt(eventRes.totalCollected)).to.equal(0);
        expect(eventRes.succeeded).to.equal(false);
        console.log(eventName);
        console.log(eventRes);
    })







    // it('test czasu', async function(){
    //     let contract = await CrowdFundingWithDeadline.new( //using the object of our SC and calling the 'new' method
    //         //we need to provide 4 parameters
    //         'funding', //contract name
    //         1, //target amount
    //         10, //duration in mins
    //         beneficiary, //ben. address
    //         //we have to provide two more parameters 
    //         {
    //             from: contractCreator, //address of an account that will deploy this Sc 
    //             gas: 2000000 //max amount of gas that we are willing to pay to deploy SC
    //         }
        

    //     );
    //     console.log("dupa")

    //     console.log(await contract.currentTime())
    //     console.log("dupa2")
    //     await contract.setCurrentTime(600)
    //     console.log(await contract.currentTime())
    // })
    
})